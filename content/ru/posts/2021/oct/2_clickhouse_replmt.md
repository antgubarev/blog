---
title: Материализованные представления и ReplacingMergeTree в Clickhouse (ч2)
date: "2021-10-21"
keywords: "clickhouse, replacingmergetree, replacing merge tree"
description: "работа с движком ReplacingMergeTree в ClickHouse на примерах"
aliases:
    - "/ru/posts/clickhousereplmt/"
---

- Часть 1. [Материализованные представления]({{< ref "/posts/2021/oct/1_clickhouse_mv.md" >}})
- **Часть 2. ReplacingMergeTree**
- Часть 3. Материализованные представления и ReplacingMergeTree в одном флаконе


[В предыдущей части]({{< ref "/posts/2021/oct/1_clickhouse_mv.md" >}}) я разобрал на примерах работу с материализованными представлениями. Теперь попробуем добавить сюда [ReplacingMergeTree](https://clickhouse.com/docs/ru/engines/table-engines/mergetree-family/replacingmergetree/). Как описано в документации

> выполняет удаление дублирующихся записей с одинаковым значением ключа сортировки (секция ORDER BY, не PRIMARY KEY).

Это может быть полезно когда возможны по разным причинам дубликаты записей. 
Допустим, что в прошлый пример данные собираются по крону раз в пять минут и тянутся из другой системы, 
которая эти метрики каким-то образом собирает. При таком подходе рано или поздно возникнет ситуация
когда данные придут за один и тот же период джважды. Ну или в самом синке будет ошибка, которая приведет 
к некорректному поведению. Кейсы можно придумывать долго и разнообразно.

Чтобы на примере посмотреть как это работает можно немного усложнить предыдущую задачу. Допустим, что 
потребовалось хранить максимальное время ответа приложения по-секундно. 
При этом данные попадают в таблицу из какого-то другого источника, но это значения сейчас значения не имеет. 
Важно то, что в таблице не должно быть записей с одинаковым временем для одного и того же приложения.

Сама таблица будет выглядеть следующим образом:

```sql
CREATE TABLE responses_time (
    time DateTime,
    app String,
    max_time UInt16
) engine=ReplacingMergeTree()
ORDER BY (time, app)
```

`ReplacingMergeTree` используется как раз для обеспечения той самой уникальности полей, заданных в `ORDER BY (time, app)`. 
И делает посредством перезатирания более старых дубликатов.

Итак, вставка данных:

```sql
INSERT INTO responses_time (time, app, max_time) VALUES
('2021-10-11 12:00:00', 'search', 500),
('2021-10-11 12:00:00', 'search', 600),
('2021-10-11 12:00:00', 'search', 700),
('2021-10-11 12:00:01', 'search', 250),
('2021-10-11 12:00:01', 'search', 251),
('2021-10-11 12:00:02', 'search', 310),
('2021-10-11 12:00:02', 'search', 320)
```

Результат:

```sql
SELECT * FROM responses_time

┌────────────────time─┬─app────┬─max_time─┐
│ 2021-10-11 12:00:00 │ search │      700 │
│ 2021-10-11 12:00:01 │ search │      251 │
│ 2021-10-11 12:00:02 │ search │      320 │
└─────────────────────┴────────┴──────────┘
```

ClickHouse как и ожидалось оставил только уникальные значения, которые были последними по списку. Но! 
Данные были вставлены в одном запросе и это имеет значение. Проверяем вставку, но уже отдельными запросами 
(с предварительной очисткой таблицы, для простоты эксперимента).

```sql
INSERT INTO responses_time (time, app, max_time) VALUES
('2021-10-11 12:00:00', 'search', 500),
('2021-10-11 12:00:01', 'search', 250),
('2021-10-11 12:00:02', 'search', 310)
```

А теперь второй запрос с дубликатами:

```sql
INSERT INTO responses_time (time, app, max_time) VALUES
('2021-10-11 12:00:00', 'search', 700),
('2021-10-11 12:00:01', 'search', 251),
('2021-10-11 12:00:02', 'search', 320)
```

Результат:

```sql
SELECT * FROM responses_time

┌────────────────time─┬─app────┬─max_time─┐
│ 2021-10-11 12:00:00 │ search │      500 │
│ 2021-10-11 12:00:01 │ search │      250 │
│ 2021-10-11 12:00:02 │ search │      310 │
└─────────────────────┴────────┴──────────┘
┌────────────────time─┬─app────┬─max_time─┐
│ 2021-10-11 12:00:00 │ search │      700 │
│ 2021-10-11 12:00:01 │ search │      251 │
│ 2021-10-11 12:00:02 │ search │      320 │
└─────────────────────┴────────┴──────────┘
```

ClickHouse вставил все, включая дубликаты, но в выдаче они разделены. Дело в том, что ClickHouse 
подчищает дуликаты не сразу, а спустя какое-то время. По всей видимости это асинхронный механизм 
и надеяться на него не стоит. В случаях когда данные из этой таблицы используются сразу, то это может сильно исказить 
результаты. правда, есть возможность получить результат не дожидаясь мержа ClikcHous-ом, для этого надо добавить 
`FINAL` в запросе:

```sql
SELECT * FROM responses_time FINAL ORDER BY time ASC

┌────────────────time─┬─app────┬─max_time─┐
│ 2021-10-11 12:00:00 │ search │      700 │
└─────────────────────┴────────┴──────────┘
┌────────────────time─┬─app────┬─max_time─┐
│ 2021-10-11 12:00:01 │ search │      251 │
│ 2021-10-11 12:00:02 │ search │      320 │
└─────────────────────┴────────┴──────────┘
```

Но делать так в проде категорически не рекомендуется, так как это повлечет за собой заметную деградацию производительности.

Еще один вариант решения как и в предыдущей статье: накапливать пачку за данных одну секунду и кидать ее разом в ClickHouse. 
Это кстати наиболее предпочтительный способ с точки зрения производительности, но разумеется далеко не всегда он возможен.

В последней части будет то, ради чего были первые две: Как подружить вместе материализованные представления 
и ReplacingMergeTree. 